---
tags:
url: https://docs.unity.cn/2023.2/Documentation/Manual/AsynchronousShaderCompilation.html
---

# Asynchronous shader compilation


Asynchronous shader compilation is an Editor-only feature that can improve your workflow when you have complex Shader objects with lots of shader variants.

异步着色器编译是一项仅限编辑器的功能，当您拥有包含大量着色器变体的复杂着色器对象时，可以改进您的工作流程。

---

## Overview

Shader objects can contain of hundreds or thousands of shader variants. If the Editor compiled all variants when loading a Shader object, the import process would be very slow. Instead, the Editor compiles shader variants on-demand, the first time it encounters them.

Compiling these shader variants can cause the Editor to stall for milliseconds or even seconds, depending on the graphics API and the complexity of the Shader object. To avoid these stalls, you can use asynchronous shader compilation to compile the shader variants in the background, and use placeholder Shader objects in the meantime.

```ad-note
编译着色器变体，工作量巨大，会导致Editor停滞。
为了解决这个问题，用异步编译。
```

着色器对象可以包含数百或数千个着色器变体。如果编辑器在加载 Shader 对象时编译所有变体，则导入过程会非常慢。相反，编辑器会在第一次遇到着色器变体时按需编译它们。

编译这些着色器变体可能会导致编辑器停滞几毫秒甚至几秒，具体取决于图形 API 和着色器对象的复杂性。为了避免这些停顿，您可以使用异步着色器编译在后台编译着色器变体，并同时使用占位符着色器对象。

---

## How asynchronous shader compilation works 异步着色器编译的工作原理

Asynchronous shader compilation works like this:

1. When the Editor first encounters an uncompiled shader variant, it adds the shader variant to a compilation queue on a job thread. The progress bar in the bottom right corner of the Editor shows the status of the compilation queue.
2. While the shader variant is loading, Editor renders the geometry with a placeholder shader, which appears as a plain cyan color.
3. When the Editor has finished compiling the shader variant, it renders the geometry using the shader variant.

```ad-note
右下角有着色器编译队列。
刚导入的模型为什么是青色？因为青色Shader是 着色器没编译好呢，用了个青色的Shader作为占位符给网格用了。
```

异步着色器编译的工作原理如下：
1. 当编辑器第一次遇到未编译的着色器变体时，它会将着色器变体添加到作业线程上的编译队列中。编辑器右下角的进度条显示编译队列的状态。
2. 加载着色器变体时，编辑器会使用占位符着色器渲染几何体，该占位符着色器显示为纯青色。
3. 当编辑器完成着色器变体的编译后，它会使用着色器变体渲染几何体。

#### 例外情况

The following exceptions apply:
* If you draw geometry using [`DrawProcedural`](https://docs.unity.cn/2023.2/Documentation/ScriptReference/Graphics.DrawProcedural.html) or [`CommandBuffer.DrawProcedural`](https://docs.unity.cn/2023.2/Documentation/ScriptReference/Rendering.CommandBuffer.DrawProcedural.html), the Editor doesn’t use a placeholder shader. Instead, the Editor just skips rendering this geometry until it has compiled the shader variant.
* The Unity Editor does not use asynchronous shader compilation with **Blit operations.** This is to guarantee correct output in the most common use cases.

以下例外情况适用：
* 如果您使用 DrawProcedural 或 CommandBuffer.DrawProcedural 绘制几何体，则编辑器不使用占位符着色器。相反，编辑器只是跳过渲染此几何体，直到编译了着色器变体。
* Unity 编辑器不使用带有 Blit 操作的异步着色器编译。这是为了保证最常见用例中的正确输出。

---

## Enabling and disabling asynchronous shader compilation for your project 为您的项目启用和禁用异步着色器编译

Asynchronous shader compilation is enabled by default.

To enable or disable asynchronous shader compilation:
1. Go to **Edit > Project Settings > Editor**
2. At the bottom of the Editor settings, under **Shader Compilation**, check or uncheck the **Asynchronous Shader Compilation** checkbox.

Note: Enabling and disabling asynchronous shader compilation in this way affects only the Scene and Game views by default. If you want to use it in other parts of the Editor, see Custom Editor tools and asynchronous shader compilation.

```ad-note
启用禁用异步Shader编译，只影响Scene视图和Game视图，Editor扩展中需要单独处理。
```

默认情况下启用异步着色器编译。

注意：默认情况下，以这种方式启用和禁用异步着色器编译仅影响场景和游戏视图。如果您想在编辑器的其他部分使用它，请参阅自定义编辑器工具和异步着色器编译。

---

## Enabling and disabling asynchronous shader compilation for specific rendering calls 为特定渲染调用启用和禁用异步着色器编译

You can enable or disable asynchronous shader compilation for specific rendering commands in your C# scripts.

The following instructions show you how to enable or disable the feature in an immediate scope, and a CommandBuffer scope.

#### In an immediate scope

In an immediate scope, you can use `ShaderUtil.allowAsyncCompilation`.

To do this:
1. Store the current state of `ShaderUtil.allowAsyncCompilation` in a variable.
2. Before you call the rendering commands, set `ShaderUtil.allowAsyncCompilation` to `false`
3. Call the rendering commands.
4. After calling the rendering commands, restore `ShaderUtil.allowAsyncCompilation` back to its previous state.

```ad-note
调用`Graphics.RenderMesh`前后，设置是否启用异步着色器编译。
```

在直接范围内，您可以使用 ShaderUtil.allowAsyncCompilation。

为此：
1. 将 ShaderUtil.allowAsyncCompilation 的当前状态存储在变量中。
2. 在调用渲染命令之前，请将 ShaderUtil.allowAsyncCompilation 设置为 false。
3. 调用渲染命令。
4. 调用渲染命令后，将 ShaderUtil.allowAsyncCompilation 恢复到之前的状态。

这是一个伪代码示例：

```C#
// Store the current state 
bool oldState = ShaderUtil.allowAsyncCompilation; 

// Disable async compilation 
ShaderUtil.allowAsyncCompilation = false; 

// Enter your rendering code that should never use the placeholder shader, for example UI elements or characters. 
Graphics.RenderMesh(...);

// Restore the old state 
ShaderUtil.allowAsyncCompilation = oldState;
```

#### In a CommandBuffer scope

In a CommandBuffer scope, you can use ShaderUtil.SetAsyncCompilation and ShaderUtil.RestoreAsyncCompilation.

1. Immediately before you call the rendering commands, call `ShaderUtil.SetAsyncCompilation`, and set it to `false`. Subsequent commands in the CommandBuffer won’t allow asynchronous compilation.
2. Add the rendering commands to the CommandBuffer.
3. After the rendering commands, call Shader.Util.RestoreAsyncCompilation to restore the state of asynchronous shader compilation.

```ad-note
CommandBuffer流程中，要先创建CommandBuffer，在用它DrawMesh，在此前后设置是否启用异步着色器编译。
```

在 CommandBuffer 范围中，您可以使用 ShaderUtil.SetAsyncCompilation 和 ShaderUtil.RestoreAsyncCompilation。

1. 在调用渲染命令之前，立即调用 ShaderUtil.SetAsyncCompilation，并将其设置为 false。 CommandBuffer 中的后续命令将不允许异步编译。
2. 将渲染命令添加到 CommandBuffer。
3. 执行渲染命令后，调用 Shader.Util.RestoreAsyncCompilation 恢复异步着色器编译的状态。

这是一个例子：

```C#
// Create the CommandBuffer 
CommandBuffer cmd = new CommandBuffer(); 

// Disable async compilation for subsequent commands 
ShaderUtil.SetAsyncCompilation(cmd, false); 

// Enter your rendering commands that should never use the placeholder shader, for example UI elements or characters. 
cmd.DrawMesh(...); 

// Restore the old state 
ShaderUtil.RestoreAsyncCompilation(cmd);
```


---

## Disabling asynchronous compilation for specific Shader objects 禁用特定 Shader 对象的异步编译

You can disable asynchronous shader compilation for specific Shader objects by forcing the Editor to always compile them synchronously. This is a good option for data generating Shader objects that are always present at the start of your rendering, and which are relatively quick to compile. You would most likely need this if you are performing advanced rendering.

To force synchronous compilation for a Shader object, add the `#pragma editor_sync_compilation` directive to your shader source code.

**Note:** You should not force synchronous compilation for complex Shader objects that encounter new shader variants during rendering; this can stall rendering in the Editor.

```ad-note

```


---

## Detecting asynchronous shader compilation 检测异步着色器编译

You can use C# APIs to monitor the state of asynchronous shader compilation, and perform operations when this state changes.

This is most likely useful in advanced rendering; if the placeholder shader pollutes your generated data, you can wait until compilation is complete, discard the polluted data, and regenerate a new set with the correct shader variants.

If you already know which material you are interested in, you can use `ShaderUtil.IsPassCompiled` to check the compilation status of the shader variant. When the status changes Uncompiled to Compiled, compilation is complete.

If you do not know which material you are interested in, or if you are interested in more than one material, you can use `ShaderUtil.anythingCompiling` to detect whether Unity is compiling any shader variants asynchronously. When this changes from `true` to `false`, all current compilation is complete.

```ad-note
高级功能，可以代码监控管理 异步着色器编译 状态和过程。
```

您可以使用C# API来监视异步着色器编译的状态，并在该状态发生变化时执行操作。

这在高级渲染中很可能有用；如果占位符着色器污染了生成的数据，您可以等到编译完成，丢弃污染的数据，并使用正确的着色器变体重新生成一组新数据。

如果您已经知道自己感兴趣的材质，则可以使用 ShaderUtil.IsPassCompiled 检查着色器变体的编译状态。当状态由 Uncompiled 变为 Compiled 时，编译完成。

如果您不知道对哪种材质感兴趣，或者对多种材质感兴趣，则可以使用 ShaderUtil.anythingCompiling 来检测 Unity 是否正在异步编译任何着色器变体。当该值从 true 变为 false 时，当前所有编译都已完成。

---

## Advanced rendering in the Editor and asynchronous shader compilation 编辑器中的高级渲染和异步着色器编译

Advanced rendering solutions rely on generating data once and reusing it in later frames. If the Editor uses a placeholder shader during this process, it might pollute the generated data. If this happens, you can see the cyan color or other rendering artifacts in your scene, even after the shader variants have finished compiling.

```ad-note
异步的东西很不可靠，无法保证 编译任务顺利完成、并把编译后的着色器 应用到网格上，出现问题也不容易排查。
会导致编译失败的Shader，场景中出现青色、出现渲染伪影。
为了排查问题，可以用各种粒度的方式，关闭 异步Shader编译。
```

高级渲染解决方案依赖于生成一次数据并在以后的帧中重复使用它。如果编辑器在此过程中使用占位符着色器，则可能会污染生成的数据。如果发生这种情况，即使着色器变体已完成编译，您也可以在场景中看到青色或其他渲染伪影。

To avoid this, you can:
- [Disable asynchronous shader compilation completely for your project](https://docs.unity.cn/2023.2/Documentation/Manual/AsynchronousShaderCompilation.html#enabling-disabling-project)
- [Disable asynchronous shader compilation for specific rendering calls](https://docs.unity.cn/2023.2/Documentation/Manual/AsynchronousShaderCompilation.html#enabling-disabling-calls)
- [Disable asynchronous shader compilation for a specific Shader object](https://docs.unity.cn/2023.2/Documentation/Manual/AsynchronousShaderCompilation.html#disabling-shader)
- [Detect when the source of the data pollution has finished compiling](https://docs.unity.cn/2023.2/Documentation/Manual/AsynchronousShaderCompilation.html#detecting-compilation), and then re-generate the data.

---

## Custom Editor tools and asynchronous shader compilation 自定义编辑器工具和异步着色器编译

By default, asynchronous Shader compilation works in the Game and Scene views. If you want to use it in custom Editor tools, you can enable it via C# for your custom tool.

To do this, you can enable asynchronous shader compilation for specific rendering calls.

```ad-note
在Editor扩展中，通过代码控制每次DrawMesh前后设置，决定是否启用 异步着色器编译。
```

默认情况下，异步着色器编译在游戏和场景视图中工作。如果您想在自定义编辑器工具中使用它，您可以通过 C# 为您的自定义工具启用它。

为此，您可以为特定渲染调用启用异步着色器编译。

---

### Customizing compile time rendering 自定义编译时渲染

You can make your custom tools draw something other than the placeholder shader for each material. This way, you can avoid rendering in plain cyan, and instead draw something else while the shader variant compiles.

To check if a specific shader variant has compiled, see Detecting asynchronous shader compilation.

To trigger compilation manually, you can use ShaderUtil.CompilePass. This way, you can avoid rendering with the cyan placeholder, and draw something else while the shader variant compiles.

```ad-note
异步编译期间，用青色替代渲染的默认行为，是可以自定义的。
```

您可以让自定义工具为每种材质绘制除占位符着色器之外的其他内容。这样，您可以避免以纯青色渲染，而是在着色器变体编译时绘制其他内容。

要检查特定着色器变体是否已编译，请参阅检测异步着色器编译。

要手动触发编译，可以使用ShaderUtil.CompilePass。这样，您可以避免使用青色占位符进行渲染，并在着色器变体编译时绘制其他内容。

---


