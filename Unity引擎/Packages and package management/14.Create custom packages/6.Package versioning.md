
Packages must follow Semantic Versioning (SemVer). Semantic Versioning is a strategy that allows package authors to provide information on the type of changes included in a given version, compared to the previous version, in a format that automated tools can use.

Semantic Versioning expresses versions as MAJOR.MINOR.PATCH, where MAJOR introduces one or more breaking changes, MINOR introduces one or more backward-compatible API changes, and PATCH only introduces bug fixes with no API changes at all.

When you begin to develop a package, start the version number at 0.1.0. The MAJOR version number 0 is reserved for packages in their initial development phase. During initial development, package APIs change often, frequently in a breaking manner, so keep the MAJOR version number at 0 until you consider your package stable enough and ready for use in production.

包必须遵循语义版本控制 (SemVer)。语义版本控制是一种策略，允许包作者以自动化工具可以使用的格式提供给定版本中包含的与先前版本相比的更改类型的信息。

语义版本控制将版本表示为 MAJOR.MINOR.PATCH，其中 MAJOR 引入一项或多项重大更改，MINOR 引入一项或多项向后兼容的 API 更改，而 PATCH 仅引入错误修复，根本没有 API 更改。

当您开始开发软件包时，版本号从 0.1.0 开始。主要版本号 0 是为初始开发阶段的软件包保留的。在初始开发过程中，包 API 经常发生变化，而且经常以破坏性的方式发生变化，因此请将主要版本号保持为 0，直到您认为您的包足够稳定并准备好在生产中使用。


After a package is officially ready for use in production, increment the MAJOR version to 1 and adhere to the following guidelines for subsequent changes:

```ad-note

和git一样，可以增加东西，但不能删除东西。

删除公开API，增加资源，MAJOR变化。

增加公开API，增加资源，MINOR变化。

```

包正式准备用于生产后，将主要版本增加到 1 并遵循以下后续更改指南：

| **Increment this value:**                    | **Under these conditions:**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **Example:**                                                                                                                                                                                                                                                |
| -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **MAJOR**                                    | There is at least one breaking change and neither version of the package can be substituted for the other. A breaking change includes:<br><br>至少有一个重大更改，并且两个版本的软件包都不能替代另一个版本。重大变更包括：<br>  <br>• Changing the API surface (the exposed part of the API) or features in a way that risks compilation or runtime errors.  <br>• Removing non-API features, including removing Assets or changing an Asset’s GUID.  <br>• Removing or renaming assemblies and Assets (because) the compiler might fail to locate them).  <br><br>* 以存在编译或运行时错误风险的方式更改API 表面（API 的公开部分）或功能。<br>* 删除非 API 功能，包括删除资产或更改资产的 GUID。<br>* 删除或重命名程序集和资源（因为编译器可能无法找到它们）<br>  <br>**Note**: When incrementing the major version, always reset the **PATCH** and **MINOR** values to `0`.<br><br>增加主要版本时，始终将 PATCH 和 MINOR 值重置为 0。 | Versions 1.2.3 and 2.0.0 are not compatible and cannot be used interchangeably without risk.<br><br>版本 1.2.3 和 2.0.0 不兼容，不能互换使用而不存在风险。                                                                                                                      |
| **MINOR**  <br>(same **MAJOR** value)        | The highest **MINOR** introduces functionality in a backward-compatible way. A backward-compatible (or non-breaking) API change includes:  <br><br>最高的 MINOR 以向后兼容的方式引入功能。向后兼容（或非破坏性）API 更改包括：<br>  <br>• Changing the API surface or features without risking compilation or runtime errors.  <br>• Adding non-API features.  <br>• Adding assemblies and Assets (because new items don’t have pre-existing references).  <br><br>* 更改API 表面或功能，而不会冒编译或运行时错误的风险。<br>* 添加非API 功能。<br>* 添加程序集和资产（因为新项目没有预先存在的引用）。<br>  <br>**Note**: When incrementing the minor version, always reset the **PATCH** version to `0`.<br><br>增加次要版本时，始终将 PATCH 版本重置为 0。                                                                                                                                               | You can use Version 1.3.0 to fulfill a dependency on 1.2.0, because 1.3.0 is backward-compatible. <br><br>您可以使用版本 1.3.0 来满足对 1.2.0 的依赖关系，因为 1.3.0 是向后兼容的。<br>  <br>You can’t use 1.2.0 to fulfill a dependency on 1.3.0.<br><br>您不能使用 1.2.0 来实现对 1.3.0 的依赖。 |
| **PATCH**  <br>(same **MAJOR.MINOR** values) | The highest **PATCH** introduces bug fixes without changing the API at all, in a backward-compatible way. The API doesn’t change if:<br><br>最高的 PATCH 以向后兼容的方式引入了错误修复，而根本不更改 API。在以下情况下，API 不会更改：<br>  <br>• The API surface is identical and the features remain unchanged.  <br>• The changes don’t alter the public API.<br><br>* API 表面相同且功能保持不变。<br>* 这些更改不会改变公共 API。                                                                                                                                                                                                                                                                                                                                                                                                                          | Versions 1.3.0 and 1.3.1 should be interchangeable because they have the same API, even though 1.3.1 contains a bug fix not present in 1.3.0.<br><br>版本 1.3.0 和 1.3.1 应该可以互换，因为它们具有相同的 API，即使 1.3.1 包含 1.3.0 中不存在的错误修复。                                     |


Following these versioning practices allows the Package Manager to automatically solve conflicts (when possible), or upgrade packages to newer, backward-compatible versions.

The following sections describe scenarios to help you determine how these rules affect various package elements:

* General assets (such as Audio, Textures, and Models).
* Assembly definitions (.asmdef files) and precompiled assemblies (managed .dll files)
* Package manifest files (package.json)
* Obsolete APIs

In addition to these scenarios, there is another factor that can affect some changes that would normally require only a MINOR or PATCH version increase: whether the Auto Referenced property is enabled or disabled.


遵循这些版本控制实践允许包管理器自动解决冲突（如果可能），或将包升级到更新的、向后兼容的版本。

以下部分描述了一些场景，可帮助您确定这些规则如何影响各种包元素：

* 一般资源（例如音频、纹理和模型）。
* 程序集定义（.asmdef 文件）和预编译程序集（托管 .dll 文件）
* 包清单文件 (package.json)
* 过时的 API

除了这些情况之外，还有另一个因素可能会影响某些通常只需要增加 MINOR 或 PATCH 版本的更改：“自动引用”属性是启用还是禁用。

---

## Automatic referencing

One of the properties you can set for your assembly definitions is the Auto Referenced property, which controls whether Unity automatically references the file during compilation. When this property is enabled, some changes that would normally require only a MINOR or PATCH version increase now become breaking changes.

When you disable auto-referencing, if you make any change that results in a new assembly being available, you are introducing a backward-compatible change to the API. Backward-compatible API changes, such as adding platforms, disabling Unity Test References, adding a new .asmdef, or removing Define Constraints, only require a MINOR increase.

However, when you enable auto-referencing, that newly-added assembly is implicitly added to the references of various other assemblies. Since those cases can lead to compilation errors in those other assemblies, so it requires a MAJOR increase.

Another common case occurs when you add or change versions for a package dependency. Most of the time, changing the package dependency only requires a PATCH increase. However, the new package version might contain an assembly with the Auto Referenced property enabled, which becomes a breaking change, and therefore requires a MAJOR increase.

To avoid problems like these, always try to avoid putting a third-party DLL file into an unrelated package (such as including Newtonsoft.Json.dll in a SaveGameManager package).

```ad-note

Automatic referencing 自动引用 属性，是影响很大的

```

您可以为程序集定义设置的属性之一是“自动引用”属性，该属性控制 Unity 是否在编译期间自动引用文件。启用此属性后，一些通常只需要增加 MINOR 或 PATCH 版本的更改现在变成了重大更改。

当您禁用自动引用时，如果您所做的任何更改导致新程序集可用，则您将向 API 引入向后兼容的更改。向后兼容的 API 更改（例如添加平台、禁用 Unity 测试引用、添加新的 .asmdef 或删除定义约束）仅需要轻微增加。

但是，当您启用自动引用时，新添加的程序集会隐式添加到各种其他程序集的引用中。由于这些情况可能会导致其他程序集中出现编译错误，因此需要大幅增加。

当您添加或更改包依赖项的版本时，会发生另一种常见情况。大多数时候，更改包依赖项只需要增加 PATCH 即可。但是，新的包版本可能包含启用了“自动引用”属性的程序集，这将成为重大更改，因此需要进行重大增加。

为了避免此类问题，请始终尽量避免将第三方 DLL 文件放入不相关的包中（例如将 Newtonsoft.Json.dll 包含在 SaveGameManager 包中）。

---

## Assets

A project can reference any asset that is visible to the Asset Database. The Asset Database tracks these assets uniquely using the GUIDs defined in their .meta files.

When you introduce one of these changes to the public API, this requires a new MAJOR release, because they are breaking changes:

```ad-note

.meta文件是 跟踪资产的重要途径。
变更GUID，需要MAJOR变更。

```

项目可以引用资产数据库可见的任何资产。资产数据库使用其 .meta 文件中定义的 GUID 唯一地跟踪这些资产。

当您向公共 API 引入这些更改之一时，这需要新的主要版本，因为它们是重大更改：

| **Scenario:**                                                               | **Why these are breaking changes:**                                                                                                                                                                                                                                                                                                                                                    |
| --------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Removing an Asset that is visible to the Asset Database<br><br>删除资产数据库可见的资产 | If you remove an Asset, this might break references in user Projects or other packages.<br><br>如果删除资产，可能会破坏用户项目或其他包中的引用。                                                                                                                                                                                                                                                               |
| Changing the GUID of an Asset<br><br>更改资产的 GUID                             | If you change an Asset GUID, the Asset Database understands this as removing the original Asset and then adding a new (identical) Asset. This results in a broken reference, because the original GUID no longer points to the Asset, so the Asset Database cannot resolve the reference.<br><br>如果您更改资产 GUID，资产数据库会将其理解为删除原始资产，然后添加新的（相同）资产。这会导致引用损坏，因为原始 GUID 不再指向资产，因此资产数据库无法解析该引用。 |


---


## Assemblies

Assembly definitions (.asmdef) define a group of scripts which the Unity Editor’s compilation pipeline turns into separate managed assemblies (.dll). These .asmdef assets include properties that drive the resulting assembly’s properties. This includes:

- Importer settings, such as included and excluded platforms
- Compilation-related properties, such as output assembly names and references fed to the compiler to build the assembly.

Most properties have an impact on the consumers of the assembly, so changing any of these properties constitutes a change to the package’s public API. Other properties have no impact on the consumers of the assembly, so changing any of these is not considered changing the package API.

Warning: The Auto Referenced property is a special case, because many of the changes that would normally not change the API at all or would change the API in a backward-compatible way could cause compilation errors, depending on whether or not it is enabled. For more information, see Automatic referencing.

Unity can either pre-compile assemblies, or compile them from scripts and an assembly definition. Therefore, anything that applies to assembly definitions generally also applies to precompiled assemblies.

This section details changes in assembly definitions and precompiled assemblies, and the impact on the package version:

* Breaking changes (allowed in new MAJOR releases only)
* Backwards-compatible API changes (allowed in new MAJOR or MINOR releases)
* Backwards-compatible changes that do not alter the API (allowed in new MAJOR, MINOR or PATCH releases)

程序集定义 (.asmdef) 定义一组脚本，Unity 编辑器的编译管道将这些脚本转换为单独的托管程序集 (.dll)。这些 .asmdef 资产包括驱动生成的程序集属性的属性。这包括：

* 导入器设置，例如包含和排除的平台
* 与编译相关的属性，例如输出程序集名称和提供给编译器以构建程序集的引用。

大多数属性都会对程序集的使用者产生影响，因此更改任何这些属性都会构成对包的公共 API 的更改。其他属性对程序集的使用者没有影响，因此更改其中任何一个属性都不会被视为更改包 API。

警告：“自动引用”属性是一种特殊情况，因为许多通常不会更改 API 或以向后兼容方式更改 API 的更改可能会导致编译错误，具体取决于是否启用它。有关详细信息，请参阅自动参考。

Unity 可以预编译程序集，也可以从脚本和程序集定义编译它们。因此，适用于程序集定义的任何内容通常也适用于预编译程序集。

本节详细介绍程序集定义和预编译程序集的更改以及对包版本的影响：

* 重大更改（仅在新的主要版本中允许）
* 向后兼容的 API 更改（在新的主要或次要版本中允许）
* 向后兼容的更改不会改变 API（在新的 MAJOR、MINOR 或 PATCH 版本中允许）

---


### MAJOR only: breaking changes

When you introduce a breaking change to the public API, this requires a new MAJOR release, because it might cause compilation and runtime errors. These scenarios all remove or hide an assembly from any other assemblies that reference it. When an assembly using a type defined in a referenced assembly is compiled, if the compiler cannot find that other assembly, that results in compilation errors. For more information about working with assemblies and assembly definitions, see Assembly Definitions.

Note that the following applies to both run-time and Editor assemblies that packages consume and use. It doesn’t apply to test assemblies, because packages do not normally consume them, so they are not part of a package’s API.

|**Scenario:**|**Why the compiler can’t find the referenced assembly:**|
|---|---|
|Removing an assembly definition or a precompiled assembly|Removing an assembly definition file prevents the compilation pipeline from generating the corresponding assembly.  <br>  <br>**Note**: As of 2019.1, missing references are allowed to support the “optional reference” use case, but renaming an assembly that Unity needs to compile an assembly definition causes compilation errors. Likewise, if compiled code needs a type from an assembly, renaming that assembly can result in run-time errors such as `TypeLoadException`.|
|Changing an assembly name (either in the _.asmdef_ file or renaming the _.dll_ file)|Changing the assembly name is equivalent to removing the assembly and then adding a new one with a different name. This means Unity considers the original assembly to be missing, even though the API still contains the same assembly code under another name.|
|Adding a [define constraint](https://docs.unity3d.com/6000.2/Documentation/ScriptReference/PluginImporter.DefineConstraints.html) to an _.asmdef_|If you add a define constraint, Unity skips compiling the assembly whenever the define constraint is not met. This creates cases where the assembly is missing, even though it was previously available.|
|[Removing platforms](https://docs.unity3d.com/6000.2/Documentation/Manual/assembly-definitions-creating.html#create-platform-specific)|If you remove support for a specific platform, Unity no longer imports the assembly on that platform, which is equivalent to removing the assembly.  <br>  <br>You can remove a platform by enabling one of these properties:  <br>• **includePlatforms**, which breaks compatibility with all unlisted platforms  <br>• **excludePlatforms**, which adds entries to it|
|Moving public APIs from one assembly to another|When you move publicly accessible code from Assembly A to Assembly B, any assembly that references A but not B fails to compile.  <br>  <br>For assembly definitions, if you move scripts around, you might be moving public APIs to a different assembly.|
|Changing the **Auto Referenced** property|When you _disable_ the **Auto Referenced** property, you can no longer use the public API of this assembly without an explicit reference:  <br>  <br>• For precompiled assemblies, disabling this property prevents Unity from implicitly adding the precompiled assembly as a reference to assembly definitions and project-compiled assemblies.  <br>• For assembly definitions, disabling this property prevents Unity from implicitly adding the resulting assembly as a reference to project-compiled assemblies.  <br>  <br>When you _enable_ the **Auto Referenced** property, it potentially introduces conflicts with other changes to the API, properties, or dependencies. For more information, see the [Automatic referencing](https://docs.unity3d.com/6000.2/Documentation/Manual/upm-semver.html#autoref) section.|
|Enabling the **Unity References → Test Assemblies** property in assembly definitions|Enabling the **Unity References → Test Assemblies** property marks this assembly as a test assembly, and Unity doesn’t normally include it in builds (or compile it in some cases). When this happens, any assembly referencing the missing assembly fails to locate it, unless it is also a test assembly.|

---

### MAJOR, MINOR: non-breaking API changes

The following changes are backward-compatible, or non-breaking, API changes. These scenarios all add an assembly, unlike breaking changes which remove an assembly. Since adding an assembly increases the API surface (the exposed part of the API), it is considered an API change. However, there are no existing references, so adding a new assembly won’t affect other assemblies created with an earlier API.

Backward-compatible changes require at least a new MINOR release. If you are including other updates that are breaking changes, then these can also be part of the new MAJOR release.

Warning: These changes are only backward-compatible if the Auto Referenced property is disabled. When the Auto Referenced property is enabled, the changes listed in this table might result in breaking changes. For more information, see the Automatic referencing section.

|**Scenario**|**Why these changes don’t break compilation**|
|---|---|
|Removing a [define constraint](https://docs.unity3d.com/6000.2/Documentation/ScriptReference/PluginImporter.DefineConstraints.html) to an .asmdef|Removing a define constraint means that the compilation and scripting pipelines no longer skip this assembly. Because Unity always builds that assembly, the compiler can always resolve references to it, regardless of whether or not that define constraint is met.|
|Adding platforms|Adding platforms has no effect on existing platform support, so it is backwards-compatible. This is an API change because it increases the API surface.  <br>  <br>You can add platforms by modifying these properties:  <br>• Add entries to the **includePlatforms** property.  <br>• Remove the **includePlatforms** property completely. This is equivalent to adding all platforms that were not already in the **includePlatforms** property.  <br>• Remove entries from the **excludePlatforms** property.|
|Creating an assembly definition with new scripts (not previously under a different _.asmdef_ file)|Adding a new assembly increases the API surface (the exposed part of the API) without altering any existing implementations.|
|Disabling the **Unity References → Test Assemblies** property in assembly definition files|Disabling the **Unity References → Test Assemblies** property marks this assembly as a regular assembly, so Unity no longer treats it differently from any assembly definition. This is an API change because it increases the API surface.|

---

### MAJOR, MINOR, PATCH: no API changes

The following changes do not affect the public API and are allowed in PATCH releases. The changes in these scenarios don’t alter the public API because they don’t affect the API surface (the exposed part of the API) and don’t change anything for other consumers.

Changes that don’t alter the public API require at least a new PATCH release. If you are including other updates that introduce either breaking or non-breaking changes, then you can also include them in MAJOR or MINOR releases.

以下更改不会影响公共 API，并且在 PATCH 版本中允许。这些场景中的更改不会改变公共 API，因为它们不会影响 API 表面（API 的公开部分），也不会为其他使用者改变任何内容。

不改变公共 API 的更改至少需要新的补丁版本。如果您要包含引入重大或非重大更改的其他更新，那么您也可以将它们包含在主要或次要版本中。

| **Scenario**                                                                                                                | **Why these changes don’t impact other consumers**                                                                                                                                                                                                                                                                                     |
| --------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Changing the list of referenced assemblies and assembly definitions in _.asmdef_ files<br><br>更改 .asmdef 文件中引用的程序集和程序集定义的列表 | An assembly that references another assembly does not automatically reference that other assembly’s own references, but has to explicitly list them. Therefore, changing references in an assembly definition or assembly does not impact other consumers.<br><br>引用另一个程序集的程序集不会自动引用该其他程序集自己的引用，但必须显式列出它们。因此，更改程序集定义或程序集中的引用不会影响其他使用者。 |
| Changing the **Allow unsafe code** property in assembly definitions<br><br>更改程序集定义中的允许不安全代码属性                               | This property controls whether the compiler is allowed to compile code that has the **unsafe** modifier. Changing that flag on its own does not alter the public API.<br><br>此属性控制是否允许编译器编译具有 unsafe 修饰符的代码。单独更改该标志不会改变公共 API。                                                                                                         |
| Changing the **Override References** property in assembly definitions<br><br>更改程序集定义中的覆盖引用属性                                | This property controls how Unity invokes the compiler for this assembly, and has no effect on consumers of the resulting assembly. Changing that flag on its own does not alter the public API.<br><br>此属性控制 Unity 如何调用该程序集的编译器，并且对生成的程序集的使用者没有影响。单独更改该标志不会改变公共 API。                                                                   |


---


## Package manifest files

The package manifest file (package.json) specifies the name, version, package dependencies, and other metadata about the package itself.

This section details changes in package manifest files, and the impact on the package version:

* Name changes (not allowed)
* Changes in dependencies (the context determines the minimum version change)
* Other changes (allowed in new MAJOR, MINOR or PATCH releases)

包清单文件 (package.json) 指定名称、版本、包依赖项以及有关包本身的其他元数据。

本节详细介绍了软件包清单文件中的更改以及对软件包版本的影响：

* 姓名变更（不允许）
* 依赖项的变化（上下文决定最小版本变化）
* 其他更改（新的 MAJOR、MINOR 或 PATCH 版本中允许）

---


### Name changes (not allowed)

Changing the name property is the equivalent of removing one package and adding a new package with a different name, and it is not supported. You cannot rename a package by trying to release an update: you have to release it as an entirely new package. Name changes aren’t allowed because existing projects and packages cannot interpret the names as synonyms.

更改 name 属性相当于删除一个包并添加一个具有不同名称的新包，并且不受支持。您无法通过尝试发布更新来重命名软件包：您必须将其作为全新的软件包发布。不允许更改名称，因为现有项目和包无法将名称解释为同义词。


---

### Dependency changes

Changing a dependency in a project does not in itself require a different MAJOR or MINOR version, unless it is part of an API change or if the Auto Referenced property is enabled.

更改项目中的依赖项本身并不需要不同的 MAJOR 或 MINOR 版本，除非它是 API 更改的一部分或者启用了“自动引用”属性。

This section provides examples of dependency changes and the contexts in which they apply (assuming that the Auto Referenced property is disabled and there is no API change other than what each case describes):

本节提供依赖项更改及其应用上下文的示例（假设“自动引用”属性已禁用，并且除了每种情况所描述的内容之外没有 API 更改）：

| **Dependency change**                  | **Context**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | **Minimum version change** |
| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------- |
| Adding a new dependency<br><br>添加新的依赖项 | • Uses the new package without changing functional behavior, and doesn’t change the API surface.<br><br>使用新包而不改变功能行为，并且不改变API 表面。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | PATCH                      |
|                                        | • Uses the new package to introduce new behavior, without modifying the API surface.  <br>• Creates new APIs that expose types defined in the new package.<br><br>使用新包引入新行为，而不修改API 表面。<br><br>创建新的API，公开新包中定义的类型。                                                                                                                                                                                                                                                                                                                                                                                                                    | MINOR                      |
|                                        | • Uses the new package to change existing behavior in a way that is not backwards-compatible, without modifying the API surface.  <br>• Modifies existing APIs in a way that is not backwards-compatible to expose types defined in the new package.<br><br>使用新包以不向后兼容的方式更改现有行为，而无需修改API 表面。<br><br>以不向后兼容的方式修改现有API 以公开新包中定义的类型。                                                                                                                                                                                                                                                                                                     | MAJOR                      |
| Removing a dependency                  | • Removes the package without changing functional behavior, and doesn’t change the API surface.<br><br>删除包而不改变功能行为，并且不改变API 表面。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | PATCH                      |
|                                        | • Removing the package results in a change in existing behavior in a way that is not backwards-compatible, without changing the API surface.  <br>• Removes APIs that expose types defined in that dependency.<br><br>删除软件包会导致现有行为以不向后兼容的方式发生更改，但不会更改 API 表面。                                                                                                                                                                                                                                                                                                                                                                         | MAJOR                      |
| Changing a dependency<br><br>更改依赖项     | • Uses the modified package without changing functional behavior, and doesn’t change the API surface.<br><br>使用修改后的包而不改变功能行为，并且不改变API 表面。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | PATCH                      |
|                                        | • Uses the modified package to introduce new behavior, without modifying the API surface.  <br>• Creates new APIs that expose types defined in the modified package.<br><br>使用修改后的包引入新行为，而不修改API 表面。<br><br>创建新的API，公开修改后的包中定义的类型。                                                                                                                                                                                                                                                                                                                                                                                                    | MINOR                      |
|                                        | • Uses the modified package to change existing behavior in a way that is not backwards-compatible, without modifying the API surface.  <br>• Changes existing APIs in a way that is not backwards-compatible to expose types defined in the modified package.  <br>• Exposes some types in APIs that are changed in a non-backward-compatible way in the modified package.  <br>• Exposes some types in APIs that are no longer defined in the modified package.<br><br>使用修改后的包以不向后兼容的方式更改现有行为，而无需修改API 表面。<br><br>以不向后兼容的方式更改现有 API，以公开修改后的包中定义的类型。<br><br>公开API 中的某些类型，这些类型在修改后的包中以非向后兼容的方式更改。<br><br>公开API 中的某些类型，这些类型在修改后的包中不再定义。 | MAJOR                      |


---


### MAJOR, MINOR or PATCH: other changes

You can change package manifest attributes that have no special effect on the Package Manager, the build pipeline, the scripting pipeline or the Asset Database in any release version. This includes changing the description, the category, the keywords, or the displayName.

If you change these fields, that might indicate that your changes involve more than just bug fixes. Always consider whether other changes in the new version actually mandate a new MINOR or MAJOR release rather than a PATCH release.

Note: Changes to the unity or unityRelease properties in a package’s manifest always require either a MINOR or MAJOR release. Although the properties do not affect the package API itself, increasing the Unity version excludes a package version from working on previous Unity editors and might break a dependent project or package. Decreasing the Unity version makes the package available to older Unity editors.


您可以更改包清单属性，这些属性对任何发行版本中的包管理器、构建管道、脚本管道或资产数据库没有特殊影响。这包括更改描述、类别、关键字或显示名称。

如果您更改这些字段，则可能表明您的更改不仅仅涉及错误修复。始终考虑新版本中的其他更改是否实际上要求新的次要或主要版本而不是补丁版本。

注意：对包清单中的 unity 或 unityRelease 属性的更改始终需要 MINOR 或 MAJOR 版本。尽管这些属性不会影响包 API 本身，但增加 Unity 版本会导致包版本无法在以前的 Unity 编辑器上运行，并且可能会破坏依赖的项目或包。降低 Unity 版本使旧版 Unity 编辑器可以使用该包。


---

## Deprecated and obsolete APIs

When you want to remove some functionality from your API, first release at least one MINOR version containing the deprecation. This warns users about the impending removal, so they can transition to the new API smoothly. Then you can remove the functionality in a new MAJOR release.

If another developer marks a package obsolete with a warning and you enabled Warnings as Errors in your project, the obsolete package might technically break your project, even though it is not a true break because the code still works as it did previously.

In this case, you can choose how you want to fix the warning-as-error (in descending order of typical desirability):

* Change your code so you no longer use the API.
* Wrap your code that uses the API in `#pragma warning` directives to silence the warning.
* Disable warnings CS0612 (Obsolete) and CS0618 (Obsolete with a message).
* Disable Warnings as Errors in your project.

```ad-note

抑制 过时API警告

```

当您想要从 API 中删除某些功能时，请首先发布至少一个包含弃用内容的次要版本。这会警告用户即将删除，以便他们可以顺利过渡到新的 API。然后您可以在新的主要版本中删除该功能。

如果另一个开发人员用警告将某个包标记为过时，并且您在项目中启用了警告作为错误，则过时的包可能会在技术上破坏您的项目，即使这不是真正的破坏，因为代码仍然像以前一样工作。

在这种情况下，您可以选择如何修复错误警告（按典型需求的降序排列）：

* 更改您的代码，以便您不再使用该 API。
* 将使用 API 的代码包装在 `#pragma warning` 指令中以消除警告。
* 禁用警告 CS0612（已过时）和 CS0618（已过时，带有消息）。
* 在项目中禁用  Warnings as Errors。

---