
A lock file contains the results of the Package Manager’s dependency resolution for a project. Package managers use lock files to provide a deterministic result when resolving a package dependency graph. When the Unity Package Manager computes a successful resolution, it stores that resolution inside the project’s Packages folder in a JSON file called packages-lock.json. Any modification to the project manifest or to a mutable
 package’s manifest (either embedded or installed from local folder) can potentially compel the Package Manager to recalculate the resolved package versions. But as long as the version of a package in the lock file satisfies the range implied by the dependency version and the resolution strategy, the package remains locked at that version.

锁定文件包含包管理器对项目的依赖项解析的结果。包管理器在解析包依赖关系图时使用锁定文件来提供确定性结果。当 Unity 包管理器计算出成功的分辨率时，它会将该分辨率存储在项目的 Packages 文件夹中名为 packages-lock.json 的 JSON 文件中。对项目清单或可变包清单（嵌入或从本地文件夹安装）的任何修改都可能迫使包管理器重新计算已解析的包版本。但是，只要锁定文件中包的版本满足依赖项版本和解析策略隐含的范围，该包就会保持锁定在该版本。

For example, here is a typical entry in the lock file:

```json
"com.unity.textmeshpro": {
  "version": "2.0.1",
  "depth": 0,
  "source": "registry",
  "dependencies": {
    "com.unity.ugui": "2.0.0"
  },
  "url": "https://packages.unity.com"
},
    etc.
```

When the Package Manager resolves any conflicting indirect dependencies, it tries to re-use as many locked packages as possible. This guarantees that subsequent dependency resolution produces the same results for the same set of dependencies. It also minimizes time-consuming operations such as downloading, extracting, or copying packages.

If there is no solution that only includes locked packages, then the Package Manager chooses the set of packages with the least risky upgrades, preferring patch upgrades over minor or major upgrades, and minor upgrades over major upgrades. In fact, you can customize the level of risk for upgrading. For more information, see Customizing resolution strategies.

To force a refresh of indirect dependency versions, delete the lock file.

Don’t manually modify the lock file: the Package Manager creates and maintains the lock file, so it overwrites any changes you make to the file.

Put the lock file under source control so you can consistently reproduce the same package set to ensure your project remains consistent over time and on different machines.

```ad-note

如果想强制刷新间接依赖版本，可以删除lock file

```

当包管理器解决任何冲突的间接依赖关系时，它会尝试重新使用尽可能多的锁定包。这保证了后续的依赖关系解析对于同一组依赖关系产生相同的结果。它还最大限度地减少了下载、解压或复制包等耗时的操作。

如果没有仅包含锁定软件包的解决方案，则软件包管理器会选择升级风险最小的软件包集，优先选择补丁升级而不是次要或主要升级，优先选择次要升级而不是主要升级。事实上，您可以自定义升级的风险级别。有关详细信息，请参阅自定义解析策略。

要强制刷新间接依赖版本，请删除锁定文件。

不要手动修改锁定文件：包管理器创建并维护锁定文件，因此它会覆盖您对该文件所做的任何更改。

将锁定文件置于源代码管理之下，以便您可以一致地重现相同的包集，以确保您的项目随着时间的推移和在不同的计算机上保持一致。

---


## Disabling the lock file

By default, the Package Manager creates or updates the lock file when it successfully computes a dependency graph. If you see unexpected results, you can set the enableLockFile property to false in your project manifest to disable locking. However, if you disable the lock file, the Package Manager clones Git URL packages again, which leads to reduced performance and additional network usage. It might also lead to non-deterministic results if you push newer commits to the remote Git repository between two resolutions.

默认情况下，包管理器在成功计算依赖关系图时创建或更新锁定文件。如果您看到意外结果，可以在项目清单中将enableLockFile 属性设置为 false 以禁用锁定。但是，如果禁用锁定文件，包管理器会再次克隆 Git URL 包，这会导致性能下降和额外的网络使用。如果您在两个解决方案之间将较新的提交推送到远程 Git 存储库，也可能会导致不确定的结果。

---